name: Build Raspberry Pi Images

# This workflow uses pi-gen to build custom Raspberry Pi OS images
# pi-gen runs in a Docker container with proper privileges

on:
  workflow_dispatch:
    inputs:
      node_type:
        description: 'Node type to build (or "all")'
        required: true
        default: 'monitoring'
        type: choice
        options:
          - all
          - mesh-router
          - lan-router
          - gateway-wifi
          - gateway-wired
          - update-cache
          - monitoring
      version:
        description: 'Image version'
        required: true
        default: '1.0.0'
  release:
    types: [published]

env:
  MESH_VERSION: ${{ github.event.inputs.version || github.ref_name }}

jobs:
  build:
    name: Build Pi Image - ${{ matrix.node_type }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        node_type: ${{ github.event.inputs.node_type == 'all' && fromJSON('["mesh-router", "lan-router", "gateway-wifi", "gateway-wired", "update-cache", "monitoring"]') || fromJSON(format('["{0}"]', github.event.inputs.node_type || 'monitoring')) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo apt-get clean
          docker system prune -af
          sudo df -h

      - name: Prepare pi-gen config
        run: |
          mkdir -p pi-gen-config/stage-mesh/00-mesh-packages/files

          # Create package installation script
          cat > pi-gen-config/stage-mesh/00-mesh-packages/00-run.sh << 'SCRIPT'
          #!/bin/bash -e

          on_chroot << EOF
          # Update system
          apt-get update
          apt-get upgrade -y

          # Install common packages
          apt-get install -y \
            git curl wget \
            python3 python3-pip python3-venv \
            network-manager \
            iptables iproute2 \
            frr \
            etcd-server etcd-client \
            vim nano \
            htop tmux

          # Configure FRR
          cat > /etc/frr/daemons << 'FRRCONF'
          frr=yes
          zebra=yes
          ospfd=yes
          FRRCONF
          systemctl enable frr

          # Configure etcd
          systemctl enable etcd

          # Enable SSH
          systemctl enable ssh
          EOF
          SCRIPT
          chmod +x pi-gen-config/stage-mesh/00-mesh-packages/00-run.sh

          # Create node-type specific script
          cat > pi-gen-config/stage-mesh/00-mesh-packages/01-run.sh << 'SCRIPT'
          #!/bin/bash -e

          NODE_TYPE="${NODE_TYPE:-monitoring}"

          on_chroot << EOF
          case "${NODE_TYPE}" in
            mesh-router|gateway-wifi)
              apt-get install -y wpasupplicant hostapd wireless-tools iw
              ;;
            gateway-*)
              apt-get install -y dnsmasq fail2ban
              ;;
            update-cache)
              apt-get install -y apt-cacher-ng
              curl -fsSL https://get.docker.com | sh
              usermod -aG docker pi || true
              systemctl enable docker
              ;;
            monitoring)
              apt-get install -y postgresql-client openssh-client snmp
              curl -fsSL https://get.docker.com | sh
              usermod -aG docker pi || true
              systemctl enable docker
              ;;
          esac

          # Create mesh network directory
          mkdir -p /opt/mesh-network

          # Write version info
          cat > /etc/mesh-network-version << VEREOF
          MESH_NETWORK_VERSION=${MESH_VERSION:-1.0.0}
          NODE_TYPE=${NODE_TYPE}
          BUILD_DATE=$(date -u +'%Y-%m-%d %H:%M:%S UTC')
          ARCH=arm64
          VEREOF

          # Cleanup
          apt-get clean
          rm -rf /var/lib/apt/lists/*
          EOF
          SCRIPT
          chmod +x pi-gen-config/stage-mesh/00-mesh-packages/01-run.sh

          # Copy mesh network files
          cp -r scripts pi-gen-config/stage-mesh/00-mesh-packages/files/ 2>/dev/null || mkdir -p pi-gen-config/stage-mesh/00-mesh-packages/files/scripts
          cp -r configs pi-gen-config/stage-mesh/00-mesh-packages/files/ 2>/dev/null || mkdir -p pi-gen-config/stage-mesh/00-mesh-packages/files/configs
          cp -r systemd pi-gen-config/stage-mesh/00-mesh-packages/files/ 2>/dev/null || mkdir -p pi-gen-config/stage-mesh/00-mesh-packages/files/systemd

          # Create file copy script
          cat > pi-gen-config/stage-mesh/00-mesh-packages/02-run.sh << 'SCRIPT'
          #!/bin/bash -e

          # Copy mesh network files to image
          if [ -d "${ROOTFS_DIR}/opt/mesh-network" ]; then
            cp -r files/scripts/* "${ROOTFS_DIR}/opt/mesh-network/" 2>/dev/null || true
            cp -r files/configs "${ROOTFS_DIR}/opt/mesh-network/" 2>/dev/null || true
            cp files/systemd/*.service "${ROOTFS_DIR}/etc/systemd/system/" 2>/dev/null || true
            cp files/systemd/*.timer "${ROOTFS_DIR}/etc/systemd/system/" 2>/dev/null || true
          fi
          SCRIPT
          chmod +x pi-gen-config/stage-mesh/00-mesh-packages/02-run.sh

          # Mark stage for inclusion
          touch pi-gen-config/stage-mesh/EXPORT_IMAGE
          touch pi-gen-config/stage-mesh/EXPORT_NOOBS

      - name: Build with pi-gen
        uses: usimd/pi-gen-action@v1
        id: build
        with:
          image-name: mesh-network-${{ matrix.node_type }}-${{ env.MESH_VERSION }}
          stage-list: stage0 stage1 stage2 ./pi-gen-config/stage-mesh
          enable-noobs: false
          compression: xz
          compression-level: 9
          locale: en_US.UTF-8
          hostname: mesh-${{ matrix.node_type }}
          keyboard-keymap: us
          keyboard-layout: English (US)
          timezone: Etc/UTC
          username: pi
          password: raspberry
          wpa-essid: ''
          wpa-password: ''
          enable-ssh: 1
          pubkey-only-ssh: 0
        env:
          NODE_TYPE: ${{ matrix.node_type }}
          MESH_VERSION: ${{ env.MESH_VERSION }}

      - name: Rename and checksum
        run: |
          mkdir -p images/output

          # Find the built image
          IMAGE_FILE=$(find ${{ steps.build.outputs.image-path }} -name "*.img.xz" | head -1)

          if [ -n "$IMAGE_FILE" ]; then
            OUTPUT_NAME="mesh-network-${{ matrix.node_type }}-${{ env.MESH_VERSION }}-arm64.img.xz"
            cp "$IMAGE_FILE" "images/output/${OUTPUT_NAME}"
            cd images/output
            sha256sum "${OUTPUT_NAME}" > "${OUTPUT_NAME}.sha256"
            ls -lh
            cat *.sha256
          else
            echo "Error: No image file found!"
            find ${{ steps.build.outputs.image-path }} -type f
            exit 1
          fi

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: mesh-network-${{ matrix.node_type }}-${{ env.MESH_VERSION }}-arm64
          path: |
            images/output/*.img.xz
            images/output/*.sha256
          retention-days: 30
          compression-level: 0

      - name: Upload to Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            images/output/*.img.xz
            images/output/*.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-manifest:
    name: Create Release Manifest
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'release' || github.event.inputs.node_type == 'all'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create manifest
        run: |
          cat > manifest.json << EOF
          {
            "version": "${{ env.MESH_VERSION }}",
            "build_date": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
            "images": [
          EOF

          first=true
          for dir in artifacts/mesh-network-*; do
            if [ -d "$dir" ]; then
              node_type=$(basename "$dir" | sed 's/mesh-network-\(.*\)-.*-arm64/\1/')
              image_file=$(ls "$dir"/*.img.xz | head -1)
              sha256_file=$(ls "$dir"/*.sha256 | head -1)

              if [ -f "$image_file" ] && [ -f "$sha256_file" ]; then
                size=$(stat -c%s "$image_file")
                sha256=$(cat "$sha256_file" | awk '{print $1}')

                if [ "$first" = true ]; then
                  first=false
                else
                  echo "," >> manifest.json
                fi

                cat >> manifest.json << ITEM
              {
                "node_type": "$node_type",
                "filename": "$(basename $image_file)",
                "size": $size,
                "sha256": "$sha256"
              }
          ITEM
              fi
            fi
          done

          cat >> manifest.json << EOF
            ]
          }
          EOF

          cat manifest.json

      - name: Upload manifest
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: manifest.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [build]
    if: always()

    steps:
      - name: Create summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # Raspberry Pi Image Build Summary

          ## Images Built
          - Mesh Router (WiFi + LAN)
          - LAN Router (Wired)
          - Gateway WiFi
          - Gateway Wired
          - Update Cache (LANcache)
          - Monitoring Node (Docker)

          ## Download
          Check the Artifacts section above or the Release page for downloads.

          ## Usage
          1. Download the appropriate `.img.xz` file for your node type
          2. Verify checksum: `sha256sum -c mesh-network-*.img.xz.sha256`
          3. Extract: `xz -d mesh-network-*.img.xz`
          4. Flash to SD card: `sudo dd if=mesh-network-*.img of=/dev/sdX bs=4M status=progress`
          5. Boot your Raspberry Pi

          ## Configuration
          After first boot, configure via:
          - SSH: `ssh pi@raspberrypi.local` (default password: raspberry)
          - Run setup: `/opt/mesh-network/setup.sh`

          EOF
